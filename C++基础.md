## C/C++基础

### 1 C++语言基础

#### 1.1 C++语言特点

- C++在C语言基础上引入了面对对象的机制，同时也兼容C语言。

- C++有三大特性封装、继承、多态。

- C++语言编写出的程序结构清晰、易于扩充，程序可读性好。

- C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%；

- C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；

#### 1.2 C和C++比较

- C++是面对对象的编程语言；C语言是面对过程的编程语言。
- C++增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等
- C++可复用性高，C++引入了模板的概念
- C语言是C++的子集，C++可以很好兼容C语言

#### 1.3 C规则

##### 1.3.1 头文件

尖括号<>的头文件是系统文件，查找路径：编译器设置的头文件路径-->系统变量。

双引号""的头文件是自定义文件，查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

##### 1.3.2 结构体

在C++中，struct数据结构集合，class是对象数据封装；struct的默认访问控制权限和继承方式public，class的默认访问控制权限和继承方式private；class关键字可以用于定义模板参数，而 struct 不能用于定义模板参数

|          |           C            |           C++            |
| :------: | :--------------------: | :----------------------: |
| 成员函数 |         不能有         |   可以（虚函数也可以）   |
| 静态成员 |         不能有         |           可以           |
| 访问控制 |  默认public，不能修改  | public/private/protected |
| 继承关系 |       不可以继承       | 可从类或者其他结构体继承 |
|  初始化  | 不能直接初始化数据成员 |           可以           |

C中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

##### 1.3.3 导入C函数

在C++中，导入C函数的关键字是**extern**，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

~~~c++
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译
extern "C" int strcmp(const char *s1, const char *s2);

//在C++程序里边声明该函数
extern "C"{
    #include <string.h>//string.h里边包含了要调用的C函数的声明
}
~~~

##### 1.3.4 数组

存储一个固定大小的相同类型元素的顺序集合；数组的存储空间，不是在静态区就是在栈上。

数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）

只有在定义数组时才可以使用初始化，不能将一个数组赋值给另一个数组。

~~~c++
// 数组的长度是常量
int age[10];
int cards[100] = {1};				// 正确初始化 3: 第一个元素为1，后续99个元素为int默认类型0
short age[] = {1,2,3,4,5};			// 正确初始化 4: 需要编译器来计算元素个数
double score[3]{1.0, 2.0, 90.0};	// 正确初始化 5: c++11新增
~~~

做全局变量时，不使用花括号`{}`时，元素全部初始化为类型默认值，如 `int-0`。做局部变量时，不使用花括号`{}`时，元素为类型随机值。使用花括号`{}`时，中数据按顺序初始化至数组内，剩余元素全部初始化为类型默认值，如 `int-0`。

**char数组**：

以空字符`null-char`为结尾，空字符写作`\0`，其`ASCII`码值为0，用来标记字符串的结尾。

~~~c++
char name[4] = {'y','u','a','n'};		// 字符数组，这不是字符串
char name[5] = {'y','u','a','n','\0'};	// 字符串
char name[10] = "yuan.";    // {'y', 'u', 'a', 'n', '.', '\0', '\0', '\0', '\0', '\0'};
~~~

C++中 使用`std::cout<< name;` 进行打印，他们会逐个处理字符，直至出现空字符`\0`为止。打印上述中第一个`name`， 打印完数组中元素后，将打印数组后的内存，直至打印到空字符`\0`为止。打印第二个`name`，将不会出现上述情况。

~~~cpp
char temp = 's';			// 这样可以
char temp = "s";			// 这样不行，"s" 表示是两个字符：'s' 和 '\0'组成的字符串
~~~

`"s"`实际上表示的是字符串所在的内存地址，上述语句将`内存地址`赋值给`char`类型，编译器不容许这种不合理的操作。

C++允许拼接字符串字面值，任何由空白、空格、制表符、换行符分隔的字符串都会自动进行拼接成一个。

~~~cpp
cout << "name:" "yuan-fufu." << endl;   // 空格
cout << "age:"  "18." << endl;          // 制表符
cout << "sex:"
        "boy." << endl;                 // 换行
~~~

**指针、动态数组**

 数组名、指针、数组第一个元素均表示数组第一个元素的地址。一般可以使用相同的方式使用 **数组名** 和 **指针名**，二者区别在于：可以修改指针指向的地址，数组名是常量；`sizeof(指针名)`为指针长度，`sizeof(数组名)`为数组长度。

~~~c++
int a[3][4];  
int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组
p = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]
              //所以数组指针也称指向一维数组的指针，亦称行指针。

//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。
char *str = "hello,douya!";
str[2] = 'a'; // 不能成功，C++不允许常量数据修改
~~~

##### 1.3.5 指针

**函数指针**是指向函数的指针变量，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

~~~cpp
int func(int a);  
int (*f)(int a);  
f = &func;  
~~~

函数指针的应用场景：**回调**

**nullptr**：

~~~cpp
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};

class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};

animal *pAn=nullptr;
pAn->breathe();   // 输出：animal breathe haha
fish *pFish = nullptr;
pFish->breathe(); // 输出：fish bubble
~~~

在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe()；编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this)，this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错

**野指针**就是指针指向的位置是不可知的，原因释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。避免办法：初始化置NULL、申请内存后判空、指针释放后置NULL、使用智能指针

~~~c++
int *p = NULL; //初始化置NULL
p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空
~~~

##### 1.3.6 函数

##### 1.3.7 传值方式

##### 1.3.8 运算符

#### 1.4 关键字

##### 1.4.1 static

**定义全局静态变量和局部静态变量**：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

静态函数和静态变量只能在**本源文件**中使用；

**static关键字可以用于定义类中的静态成员函数和静态成员变量**：所有对象的静态数据成员都**共享**这一块静态存储空间。

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

##### 1.4.2 define

##### 1.4.3 const

##### 1.4.4 ++



### 2 C++内存管理

#### 2.1 C++内存管理

#### 2.2 堆、栈、常量区

#### 2.3 内存泄漏

#### 2.4 内存对齐