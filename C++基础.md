## C/C++基础

### 1 C++语言基础

#### 1.1 C++语言特点

- C++在C语言基础上引入了面对对象的机制，同时也兼容C语言。

- C++有三大特性封装、继承、多态。

- C++语言编写出的程序结构清晰、易于扩充，程序可读性好。

- C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%；

- C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等；

#### 1.2 C和C++比较

- C++是面对对象的编程语言；C语言是面对过程的编程语言。
- C++增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等
- C++可复用性高，C++引入了模板的概念
- C语言是C++的子集，C++可以很好兼容C语言

#### 1.3 C规则

##### 1.3.1 头文件

尖括号<>的头文件是系统文件，查找路径：编译器设置的头文件路径-->系统变量。

双引号""的头文件是自定义文件，查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。

##### 1.3.2 结构体

在C++中，struct数据结构集合，class是对象数据封装；struct的默认访问控制权限和继承方式public，class的默认访问控制权限和继承方式private；class关键字可以用于定义模板参数，而 struct 不能用于定义模板参数

|          |           C            |           C++            |
| :------: | :--------------------: | :----------------------: |
| 成员函数 |         不能有         |   可以（虚函数也可以）   |
| 静态成员 |         不能有         |           可以           |
| 访问控制 |  默认public，不能修改  | public/private/protected |
| 继承关系 |       不可以继承       | 可从类或者其他结构体继承 |
|  初始化  | 不能直接初始化数据成员 |           可以           |

C中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用

##### 1.3.3 导入C函数

在C++中，导入C函数的关键字是**extern**，表达形式为extern “C”， extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。

~~~c++
//在C++程序里边声明该函数，会指示编译器这部分代码按C语言的进行编译
extern "C" int strcmp(const char *s1, const char *s2);

//在C++程序里边声明该函数
extern "C"{
    #include <string.h>//string.h里边包含了要调用的C函数的声明
}
~~~

##### 1.3.4 数组

存储一个固定大小的相同类型元素的顺序集合；数组的存储空间，不是在静态区就是在栈上。

数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型）

只有在定义数组时才可以使用初始化，不能将一个数组赋值给另一个数组。

~~~c++
// 数组的长度是常量
int age[10];
int cards[100] = {1};				// 正确初始化 3: 第一个元素为1，后续99个元素为int默认类型0
short age[] = {1,2,3,4,5};			// 正确初始化 4: 需要编译器来计算元素个数
double score[3]{1.0, 2.0, 90.0};	// 正确初始化 5: c++11新增
~~~

做全局变量时，不使用花括号`{}`时，元素全部初始化为类型默认值，如 `int-0`。做局部变量时，不使用花括号`{}`时，元素为类型随机值。使用花括号`{}`时，中数据按顺序初始化至数组内，剩余元素全部初始化为类型默认值，如 `int-0`。

**char数组**：

以空字符`null-char`为结尾，空字符写作`\0`，其`ASCII`码值为0，用来标记字符串的结尾。

~~~c++
char name[4] = {'y','u','a','n'};		// 字符数组，这不是字符串
char name[5] = {'y','u','a','n','\0'};	// 字符串
char name[10] = "yuan.";    // {'y', 'u', 'a', 'n', '.', '\0', '\0', '\0', '\0', '\0'};
~~~

C++中 使用`std::cout<< name;` 进行打印，他们会逐个处理字符，直至出现空字符`\0`为止。打印上述中第一个`name`， 打印完数组中元素后，将打印数组后的内存，直至打印到空字符`\0`为止。打印第二个`name`，将不会出现上述情况。

~~~cpp
char temp = 's';			// 这样可以
char temp = "s";			// 这样不行，"s" 表示是两个字符：'s' 和 '\0'组成的字符串
~~~

`"s"`实际上表示的是字符串所在的内存地址，上述语句将`内存地址`赋值给`char`类型，编译器不容许这种不合理的操作。

C++允许拼接字符串字面值，任何由空白、空格、制表符、换行符分隔的字符串都会自动进行拼接成一个。

~~~cpp
cout << "name:" "yuan-fufu." << endl;   // 空格
cout << "age:"  "18." << endl;          // 制表符
cout << "sex:"
        "boy." << endl;                 // 换行
~~~

**指针、动态数组**

 数组名、指针、数组第一个元素均表示数组第一个元素的地址。一般可以使用相同的方式使用 **数组名** 和 **指针名**，二者区别在于：可以修改指针指向的地址，数组名是常量；`sizeof(指针名)`为指针长度，`sizeof(数组名)`为数组长度。

~~~c++
int a[3][4];  
int (*p)[4];  //该语句是定义一个数组指针，指向含4个元素的一维数组
p = a;        //将该二维数组的首地址赋给p，也就是a[0]或&a[0][0]
p++;          //该语句执行过后，也就是p=p+1；p跨过行a[0][]指向了行a[1][]
              //所以数组指针也称指向一维数组的指针，亦称行指针。

//*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]。其中，优先级：()>[]>*。
char *str = "hello,douya!";
str[2] = 'a'; // 不能成功，C++不允许常量数据修改
~~~

##### 1.3.5 指针

**函数指针**是指向函数的指针变量，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。

~~~cpp
int func(int a);  
int (*f)(int a);  
f = &func;  
~~~

函数指针的应用场景：**回调**

指针函数本质是一个函数，其返回值为指针。



**nullptr**：

~~~cpp
class animal{
public:
    void sleep(){ cout << "animal sleep" << endl; }
    void breathe(){ cout << "animal breathe haha" << endl; }
};

class fish :public animal{
public:
    void breathe(){ cout << "fish bubble" << endl; }
};

animal *pAn=nullptr;
pAn->breathe();   // 输出：animal breathe haha
fish *pFish = nullptr;
pFish->breathe(); // 输出：fish bubble
~~~

在**编译时对象**就绑定了**函数地址**，和指针空不空没关系。pAn->breathe()；编译的时候，函数的地址就和指针pAn绑定了；调用breath(*this)，this就等于pAn。由于函数中没有需要解引用this的地方，所以函数运行不会出错，但是若用到this，因为this=nullptr，运行出错

**野指针**就是指针指向的位置是不可知的，原因释放内存后指针不及时置空（野指针），依然指向了该内存，那么可能出现非法访问的错误。避免办法：初始化置NULL、申请内存后判空、指针释放后置NULL、使用智能指针

~~~c++
int *p = NULL; //初始化置NULL
p = (int *)malloc(sizeof(int)*n); //申请n个int内存空间  
assert(p != NULL); //判空，防错设计
p = (int *) realloc(p, 25);//重新分配内存, p 所指向的内存块会被释放并分配一个新的内存地址
free(p);  
p = NULL; //释放后置空
~~~

##### 1.3.6 函数

内联函数和宏函数

1. **宏定义不是函数**，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；**而内联函数本质上是一个函数**，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
2. **宏函数**是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；**而内联函数**则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率
3. **宏定义**是没有类型检查的，无论对还是错都是直接替换；**而内联函数**在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等

**使用时的一些注意事项：**

- 使用宏定义一定要注意错误情况的出现，比如宏定义函数没有类型检查，可能传进来任意类型，从而带来错误，如举例。还有就是括号的使用，宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性
- inline函数一般用于比较小的——只适合于只有1～5行的小函数，频繁调用的函数，这样可以减少函数调用带来的开销。只需要在函数返回类型前加上关键字inline，即可将函数指定为inline函数。
- 同其它函数不同的是，最好将inline函数定义在头文件，而不仅仅是声明，因为编译器在处理inline函数时，需要在调用点内联展开该函数，所以仅需要函数声明是不够的。

**内联函数使用的条件：**

- 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率 的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联：
- （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。
- （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。
- 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。

##### 1.3.7 传值方式

- 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；

- 引用传递：形参在函数体内值发生变化，会影响实参的值；

- 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值；

值传递用于对象时，整个对象会拷贝一个副本，这样效率低；而引用传递用于对象时，不发生拷贝行为，只是绑定对象，更高效；指针传递同理，但不如引用传递安全。

#### 1.4 关键字

##### 1.4.1 static

**定义全局静态变量和局部静态变量**：初始化的静态变量会在数据段分配内存，未初始化的静态变量会在BSS段分配内存。直到程序结束，静态变量始终会维持前值。对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化。而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造。

静态函数和静态变量只能在**本源文件**中使用；

**static关键字可以用于定义类中的静态成员函数和静态成员变量**：所有对象的静态数据成员都**共享**这一块静态存储空间。

当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针（划重点，面试题常考）。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。

##### 1.4.2 define

define用于定义宏，宏也可以用于定义常量。

const和define都用于常量定义时，它们的区别有：

- const生效于编译的阶段；define生效于预处理阶段。

- const定义的常量，在C语言中是存储在内存中、需要额外的内存空间的；define定义的常量，运行时是直接的操作数，并不会存放在内存中。
- const定义的常量是带类型的；define定义的常量不带类型。因此define定义的常量不利于类型检查。

##### 1.4.3 const

const用于定义常量

~~~cpp
const int a;     //指的是a是一个常量，不允许修改。
const int *a;    //a指针所指向的内存里的值不变，即（*a）不变
int const *a;    //同const int *a;
int *const a;    //a指针所指向的内存地址不变，即a不变
const int *const a;   //都不变，即（*a）不变，a也不变
~~~

##### 1.4.4 ++

**赋值顺序不同**：++ i 是先加后赋值；i ++ 是先赋值后加；++i和i++都是分两步完成的。

**效率不同**：后置++执行速度比前置的慢。

**i++ 不能作为左值，而++i 可以**：左值是对应内存中有确定存储地址的对象的表达式的值

```c
int i = 0;
int *p1 = &(++i);//正确
int *p2 = &(i++);//错误
++i = 1; //正确
i++ = 1; //错误
```

**两者都不是原子操作**。

##### 1.4.5 new、malloc

new是操作符，而malloc是函数。

new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。

malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。

new可以被重载；malloc不行

new分配内存更直接和安全。

new发生错误抛出异常，malloc返回null

**malloc底层实现：**当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

**new底层实现：**关键字new在调用构造函数的时候实际上进行了如下的几个步骤：

1. 创建一个新的对象
2. 将构造函数的作用域赋值给这个新的对象（因此this指向了这个新的对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 返回新对象

### 2 C++内存管理

#### 2.1 C++内存管理

<img src="image\20220905001.png" style="zoom:80%;" />

如上图，**从低地址到高地址，一个程序由代码段、数据段、** **BSS** **段组成。**

1. **数据段：**存放程序中已初始化的全局变量和静态变量的一块内存区域。

2. **代码段：**存放程序执行代码的一块内存区域。只读，代码段的头部还会包含一些只读的常数变量。

3. **BSS** 段：存放程序中未初始化或者初始化为0的全局变量和静态变量的一块内存区域。

4. 可执行程序在运行时又会多出两个区域：堆区和栈区。

   **堆区：**动态申请内存用。堆从低地址向高地址增长。

   **栈区：**存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。

5. 最后还有一个**文件映射区**，位于堆和栈之间。

**程序启动的过程：**

1. 操作系统首先创建相应的进程并分配私有的进程空间，然后操作系统的加载器负责把可执行文件的数据段和代码段映射到进程的虚拟内存空间中。
2. 加载器读入可执行程序的导入符号表，根据这些符号表可以查找出该可执行程序的所有依赖的动态链接库。
3. 加载器针对该程序的每一个动态链接库调用LoadLibrary
   （1）查找对应的动态库文件，加载器为该动态链接库确定一个合适的基地址。
   （2）加载器读取该动态链接库的导入符号表和导出符号表，比较应用程序要求的导入符号是否匹配该库的导出符号。
   （3）针对该库的导入符号表，查找对应的依赖的动态链接库，如有跳转，则跳到3
   （4）调用该动态链接库的初始化函数
4. 初始化应用程序的全局变量，对于全局对象自动调用构造函数。
5. 进入应用程序入口点函数开始执行。



**栈**，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。

**堆**，就是那些由malloc等分配的内存块，和堆是十分相似的，不过是用free来结束自己的生命。

**自由存储区**，就是那些由new分配的内存块，一般一个new就要对应一个delete。

**全局/静态存储区**，全局变量和静态变量被分配到同一块内存中

**常量存储区**，这是一块比较特殊的存储区，里面存放的是常量，不允许修改。



**常见的内存错误及其对策**：

（1）内存分配未成功，却使用了它。

（2）内存分配虽然成功，但是尚未初始化就引用它。

（3）内存分配成功并且已经初始化，但操作越过了内存的边界。

（4）忘记了释放内存，造成内存泄露。

（5）释放了内存却继续使用它。

对策：

（1）定义指针时，先初始化为NULL。

（2）用malloc或new申请内存之后，应该**立即检查**指针值是否为NULL。防止使用指针值为NULL的内存。

（3）不要忘记为数组和动态内存**赋初值**。防止将未被初始化的内存作为右值使用。

（4）避免数字或指针的下标**越界**，特别要当心发生“多1”或者“少1”操作

（5）动态内存的申请与释放必须配对，防止**内存泄漏**

（6）用free或delete释放了内存之后，立即将指针**设置为NULL**，防止“野指针”

（7）使用智能指针。

#### 2.2 堆、栈、常量区

**堆栈区别**：

- 堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等；堆一般由程序员分配释放。

- 堆栈缓存方式不同。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。

- 堆栈数据结构不同。堆类似数组结构；栈类似栈结构，先进后出。

#### 2.3 内存泄漏

**什么是内存泄露？**

简单地说就是申请了一块内存空间，使用完毕后没有释放掉。（1）new和malloc申请资源使用后，没有用delete和free释放；（2）子类继承父类时，父类析构函数不是虚函数。（3）Windows句柄资源使用后没有释放。

**怎么检测？**

第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。

第三：使用智能指针。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind等等。

#### 2.4 内存对齐

内存对齐应用于三种数据类型中：**struct/class/union**

struct/class/union内存对齐原则有四个：

1. 数据成员对齐规则：结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始。
2. 结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部"最宽基本类型成员"的整数倍地址开始存储。(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储)。
3. 收尾工作:结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的"最宽基本类型成员"的整数倍。不足的要补齐。(基本类型不包括struct/class/uinon)。
4. sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。

**答案解析**

1. **什么是内存对齐？**

   那么什么是字节对齐？在C语言中，结构体是一种复合数据类型，其构成元素既可以是基本数据类型（如int、long、float等）的变量，也可以是一些复合数据类型（如数组、结构体、联合体等）的数据单元。在结构体中，**编译器为结构体的每个成员按其自然边界（alignment）分配空间。**各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构体的地址相同。

   为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，**即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除**，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

   比如在32位cpu下，假设一个整型变量的地址为0x00000004(为4的倍数)，那它就是自然对齐的，而如果其地址为0x00000002（非4的倍数）则是非对齐的。现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

2. **为什么要字节对齐？**

   需要字节对齐的根本原因在于CPU访问数据的效率问题。假设上面整型变量的地址不是自然对齐，比如为0x00000002，则CPU如果取它的值的话需要访问两次内存，第一次取从0x00000002-0x00000003的一个short，第二次取从0x00000004-0x00000005的一个short然后组合得到所要的数据，如果变量在0x00000003地址上的话则要访问三次内存，第一次为char，第二次为short，第三次为char，然后组合得到整型数据。

   而如果变量在自然对齐位置上，则只要一次就可以取出数据。一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。

   各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。

~~~cpp
union example {  
    int a[5];  
    char b;  
    double c;  
};  
int result = sizeof(example);  
/*
如果以最长20字节为准，内部double占8字节，这段内存的地址0x00000020并不是double的整数倍，只有当最小为0x00000024时可以满足整除double（8Byte）同时又可以容纳int a[5]的大小，所以正确的结果应该是result=24
*/

struct example {  
    int a[5];  
    char b;  
    double c;  
}test_struct;
int result = sizeof(test_struct);  
/*
如果我们不考虑字节对齐，那么内存地址0x0021不是double（8Byte）的整数倍，所以需要字节对齐，那么此时满足是double（8Byte）的整数倍的最小整数是0x0024，说明此时char b对齐int扩充了三个字节。所以最后的结果是result=32
*/

struct example {  
    char b;  
    double c;  
    int a;  
}test_struct;  
int result = sizeof(test_struct);  
/*
字节对齐除了内存起始地址要是数据类型的整数倍以外，还要满足一个条件，那就是占用的内存空间大小需要是结构体中占用最大内存空间的类型的整数倍，所以20不是double（8Byte）的整数倍，我们还要扩充四个字节，最后的结果是result=24
*/
~~~

