### 1 GCC

#### 1.1 GCC工作流程

<img src="image\202208220929.png" alt="202208220929" style="zoom: 67%;" />

#### 1.2 GCC常用参数选项

| Gcc编译选项 |                             说明                             |
| ----------- | :----------------------------------------------------------: |
| -E          | 预处理将#include，#define等进行文件插入及将宏定义替换到代码中；会删除与代码运行无关的注释。 |
| -S          | 将对源程序进行预处理、编译，生成`.s`后缀名的汇编文件，里面包含汇编代码。 |
| -c          | 在编译阶段生成的汇编文件会经过汇编器(as)的处理，生成二进制目标文件`.o` |
|             | 链接阶段是将所有相关的目标文件链接起来，形成一个整体，生成一个可执行文件。无选项链接: 这个命令会把二进制目标文件test.o所需的相关文件链接成一个整体，并在当前文件夹自动生成一个名为a.out的可执行文件。 |
| -I          |                指定include 包含文件的搜索目录                |
| -g          |      在编译的时候，生成调试信息，该程序可以被调试器调试      |
| -D          |                 在程序编译的时候，指定一个宏                 |
| -w          |                      不生成任何警告信息                      |

预编译：这个过程主要的处理操作如下：

（1） 将所有的#define删除，并且展开所有的宏定义

（2） 处理所有的条件预编译指令，如#if、#ifdef

（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

（4） 过滤所有的注释

（5） 添加行号和文件名标识。

编译：这个过程主要的处理操作如下：

（1） 词法分析：将源代码的字符序列分割成一系列的记号。

（2） 语法分析：对记号进行语法分析，产生语法树。

（3） 语义分析：判断表达式是否有意义。

（4） 代码优化：

（5） 目标代码生成：生成汇编代码。

（6） 目标代码优化：

汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

链接分为静态链接和动态链接。

静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

```shell
# 预处理
g++ test.cpp -E -o test.i
# 编译
g++ test.cpp -S -o test.s
# 汇编
g++ test.s -c -o test.o
# 链接
g++ test.o -o test.out
g++ test.o -o test
g++ test.o -o test.exe
```

### 2 MakeFile

#### 2.1 简介

#### 2.2 MakeFile文件命名和规则

#### 2.3 基本原理

#### 2.4 变量

#### 2.5 模式匹配

#### 2.6 函数

### 3 GDB

`gdb`（`GNU debugger`）是 `UNIX/Linux` 系统中强大的调试工具，它能够调试软件并分析软件的执行过程，帮助我们调查研究程序的正确行为，还能用来分析程序崩溃的原因等。

`gdb` 支持多种语言，可以支持 `C/C++` 、`Go`、`Java`、`Objective-C` 等。

#### 3.1 gdb调试执行

在编译程序时，使用 `gcc` 或者 `g++` 时一定要加上 `-g` 选项，如

```shell
gcc -g -o hello hello.c
```

以便调试程序含有调试符号信息，从而能够正常调试程序。否则则会出现如下提示，导致不能调试。

除了不加 `-g` 选项，也可以使用 `Linux` 的 `strip` 命令移除掉某个程序中的调试信息`strip hello`；使用 `strip` 命令之后，程序明显变小了，我们通常会在程序测试没问题以后，将其发布到生产环境或者正式环境中，因此生成不带调试符号信息的程序，以减小程序体积或提高程序执行效率。

**在实际生成调试程序时，一般不仅要加上 -g 选项，也建议关闭编译器的程序优化选项。这样做的目的是为了调试的时候，符号文件显示的调试变量等能与源代码完全对应起来。**

`gdb filename`直接调试目标程序

`gdb attach pid` 附加进程

`gdb filename corename` 调试 `core` 文件



当用 `gdb attach` 上目标进程后，调试器会暂停下来，此时可以在 `gdb` 中输入相关的命令，比如设置断点等，再继续运行程序，此时需要在 `gdb` 中输入命令 `c` 继续运行，程序才能恢复为正常状态。



程序在崩溃的时候有 `core` 文件产生，就可以使用这个 `core` 文件来定位崩溃的原因。使用 `ulimit -c` 命令来查看系统是否开启了 `core` 文件定位崩溃。使用 `ulimit 选项名 设置值` 来修改。可以将 `core` 文件生成改成具体某个值（是临时的）， `core file size` 选项-c表示生成 `core` 文件

~~~shell
ulimit -c unlimited
~~~

#### 3.2 置断点

#### 3. gdb命令大全

~~~shell
(gdb) list #查看代码
(gdb) list 行号
(gdb) list 函数名
(gdb) next # 执行下一行语句
(gdb) c # continue从当前位置连续执行
(gdb) detach #让程序与 GDB 调试器分离
(gdb) r #程序真正的运行起来
(gdb) q #停止运行
(gdb) set args a b c d #添加参数，如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来。
(gdb) show args #查看命令行参数是否设置成功
~~~

### 4 静态库和动态库

#### 4.1 什么是库

#### 4.2 静态库

#### 4.3 动态库

#### 4.4 工作原理

#### 4.5 区别

### 5 文件IO

#### 5.1 标准C库IO函数

#### 5.2 标准C库IO和Linux系统IO的关系

#### 5.3 虚拟地址空间

#### 5.4 文件描述符

#### 5.5 Linux系统IO函数

#### 5.6 文件属性操作函数

#### 5.7 目录操作函数

#### 5.8 目录遍历函数

#### 5.9 direct结构体和d_type

#### 5.10 dup、dup2函数

#### 5.11 fcntl函数