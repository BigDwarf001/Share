### 1 GCC

#### 1.1 GCC工作流程

<img src="image\202208220929.png" alt="202208220929" style="zoom: 67%;" />

#### 1.2 GCC常用参数选项

| Gcc编译选项 |                             说明                             |
| ----------- | :----------------------------------------------------------: |
| -E          | 预处理将#include，#define等进行文件插入及将宏定义替换到代码中；会删除与代码运行无关的注释。 |
| -S          | 将对源程序进行预处理、编译，生成`.s`后缀名的汇编文件，里面包含汇编代码。 |
| -c          | 在编译阶段生成的汇编文件会经过汇编器(as)的处理，生成二进制目标文件`.o` |
|             | 链接阶段是将所有相关的目标文件链接起来，形成一个整体，生成一个可执行文件。无选项链接: 这个命令会把二进制目标文件test.o所需的相关文件链接成一个整体，并在当前文件夹自动生成一个名为a.out的可执行文件。 |
| -I          |                指定include 包含文件的搜索目录                |
| -g          |      在编译的时候，生成调试信息，该程序可以被调试器调试      |
| -D          |                 在程序编译的时候，指定一个宏                 |
| -w          |                      不生成任何警告信息                      |

预编译：这个过程主要的处理操作如下：

（1） 将所有的#define删除，并且展开所有的宏定义

（2） 处理所有的条件预编译指令，如#if、#ifdef

（3） 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。

（4） 过滤所有的注释

（5） 添加行号和文件名标识。

编译：这个过程主要的处理操作如下：

（1） 词法分析：将源代码的字符序列分割成一系列的记号。

（2） 语法分析：对记号进行语法分析，产生语法树。

（3） 语义分析：判断表达式是否有意义。

（4） 代码优化：

（5） 目标代码生成：生成汇编代码。

（6） 目标代码优化：

汇编：这个过程主要是将汇编代码转变成机器可以执行的指令。

链接：将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。

链接分为静态链接和动态链接。

静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。

而动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。

```shell
# 预处理
g++ test.cpp -E -o test.i
# 编译
g++ test.cpp -S -o test.s
# 汇编
g++ test.s -c -o test.o
# 链接
g++ test.o -o test.out
g++ test.o -o test
g++ test.o -o test.exe
```

### 2 MakeFile

#### 2.1 简介

#### 2.2 MakeFile文件命名和规则

#### 2.3 基本原理

#### 2.4 变量

#### 2.5 模式匹配

#### 2.6 函数

### 3 GDB

`gdb`（`GNU debugger`）是 `UNIX/Linux` 系统中强大的调试工具，它能够调试软件并分析软件的执行过程，帮助我们调查研究程序的正确行为，还能用来分析程序崩溃的原因等。

`gdb` 支持多种语言，可以支持 `C/C++` 、`Go`、`Java`、`Objective-C` 等。

#### 3.1 gdb调试执行

**在编译程序时，使用 `gcc` 或者 `g++` 时一定要加上 `-g` 选项**，如

```shell
gcc -g -o hello hello.c
```

以便调试程序含有调试符号信息，从而能够正常调试程序。否则则会出现如下提示，导致不能调试。

除了不加 `-g` 选项，也可以使用 `Linux` 的 `strip` 命令移除掉某个程序中的调试信息`strip hello`；使用 `strip` 命令之后，程序明显变小了，我们通常会在程序测试没问题以后，将其发布到生产环境或者正式环境中，因此生成不带调试符号信息的程序，以减小程序体积或提高程序执行效率。

**在实际生成调试程序时，一般不仅要加上 -g 选项，也建议关闭编译器的程序优化选项。这样做的目的是为了调试的时候，符号文件显示的调试变量等能与源代码完全对应起来。**

`gdb filename`直接调试目标程序

`gdb attach pid` 附加进程

`gdb filename corename` 调试 `core` 文件



当用 `gdb attach` 上目标进程后，调试器会暂停下来，此时可以在 `gdb` 中输入相关的命令，比如设置断点等，再继续运行程序，此时需要在 `gdb` 中输入命令 `c` 继续运行，程序才能恢复为正常状态。



程序在崩溃的时候有 `core` 文件产生，就可以使用这个 `core` 文件来定位崩溃的原因。使用 `ulimit -c` 命令来查看系统是否开启了 `core` 文件定位崩溃。使用 `ulimit 选项名 设置值` 来修改。可以将 `core` 文件生成改成具体某个值（是临时的）， `core file size` 选项-c表示生成 `core` 文件

~~~shell
ulimit -c unlimited
~~~

#### 3.2 置断点

~~~shell
#在代码的某一行设置断点
(gdb) break 文件名:行号
#为函数设置断点
(gdb) break 函数名
#使用正则表达式设置函数断点
(gdb) rb 正则表达式
# 通过偏移量设置断点
(gdb) b +偏移量  
(gdb) b -偏移量
#设置条件断点
(gdb) b 断点 条件
(gdb) b demo.cpp:8 if i==900
#在指令地址上设置断点
(gdb) b *指令地址
(gdb) p fun_test
(gdb) b *0x400a0b
# 设置临时断点 
(gdb) tb 断点
#启用禁用断点
(gdb) disable   断点编号（可以是范围）
(gdb) enable   断点编号
#启用禁用一次断点
(gdb) enable once 断点编号
#启用断点并删除
(gdb) enable delete 断点编号
#启用断点并命中N次
(gdb) enable count 数量 断点编号
#忽略断点前N次命中
(gdb) ignore 断点编号 次数
#删除断点
(gdb) delete 断点编号
(gdb) clear 函数名
(gdb) clear 行号
#继续运行并跳过当前断点 N 次
(gdb) continue 次数
#继续运行直到当前函数执行完成
(gdb) finish
~~~

#### 3.3 查看当前参数

~~~shell
#查看变量
(gdb) p/print c 
(gdb) print 变量名=值
#断点
(gdb) info b #断点信息
#参数
(gdb) info/i args
#gdb内嵌函数，比如一些c函数sizeof、strcmp
(gdb) p sizeof(int)
#查看结构体/类的值
(gdb) p *new_node
#print格式
(gdb) set print null-stop
(gdb) set print pretty
(gdb) set print array on
#自动显示变量的值，如果 display 命令后面跟多个变量名，则必须要求这些变量的类型相同（比如都是整型变量）。如果长度不相同，则需要分开使用。
(gdb) display 变量名
(gdb) info display
undisplay 编号
~~~

#### 3.4 监控内存

watch命令的使用方式是

```shell
(gdb) watch 变量名或内存地址
#当设置的观察点是一个局部变量时，局部变量无效后，观察点也会失效。在观察点失效时 `GDB` 可能会提示如下信息：
Watchpoint 2 deleted because the program has left the block in which its expression is valid.
```

查看内存使用 `x` 命令查看各个变量的内存信息

~~~
(gdb) x /选项 地址
~~~

#### 3.5 栈回溯

查看栈回溯信息的命令是 `backtrace`，通过 `frame 栈帧号` 的方式来切换栈帧

~~~shell
#执行命令来查看指定数量的栈帧
(gdb) bt 栈帧数量
#切换栈帧
(gdb) frame 2 
(gdb) f 2
(gdb) f 帧地址
(gdb) up/down 
#查看当前帧的所有局部变量的值
(gdb) info locals
~~~

#### 3.6 gdb命令大全

~~~shell
(gdb) list #查看代码
(gdb) list 行号
(gdb) list 函数名
(gdb) s #单步执行
(gdb) next # 执行下一行语句
(gdb) c # continue从当前位置连续执行
(gdb) detach #让程序与 GDB 调试器分离
(gdb) r #程序真正的运行起来
(gdb) q #停止运行
(gdb) set args a b c d #添加参数，如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来。
(gdb) show args #查看命令行参数是否设置成功

~~~

### 4 静态库和动态库

#### 4.1 什么是库

#### 4.2 静态库

#### 4.3 动态库

#### 4.4 工作原理

#### 4.5 区别

### 5 文件IO

#### 5.1 标准C库IO函数

#### 5.2 标准C库IO和Linux系统IO的关系

#### 5.3 虚拟地址空间

#### 5.4 文件描述符

#### 5.5 Linux系统IO函数

#### 5.6 文件属性操作函数

#### 5.7 目录操作函数

#### 5.8 目录遍历函数

#### 5.9 direct结构体和d_type

#### 5.10 dup、dup2函数

#### 5.11 fcntl函数